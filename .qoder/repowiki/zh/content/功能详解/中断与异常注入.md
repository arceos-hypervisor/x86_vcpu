# 中断与异常注入

<cite>
**本文档中引用的文件**
- [vmcs.rs](file://src/vmx/vmcs.rs)
- [vcpu.rs](file://src/vmx/vcpu.rs)
- [definitions.rs](file://src/vmx/definitions.rs)
</cite>

## 目录
1. [简介](#简介)
2. [中断注入机制概述](#中断注入机制概述)
3. [VMCS字段配置](#vmcs字段配置)
4. [中断类型编码规则](#中断类型编码规则)
5. [错误码处理](#错误码处理)
6. [注入方法调用流程](#注入方法调用流程)
7. [前置条件检查](#前置条件检查)
8. [PIC/IOAPIC中断模拟示例](#picioapic中断模拟示例)
9. [注入失败原因分析](#注入失败原因分析)
10. [多核环境同步注意事项](#多核环境同步注意事项)

## 简介
本文档详细描述了在x86虚拟化环境中向guest vCPU注入外部中断、异常和软中断的机制。基于Intel VT-x技术，通过VMCS（Virtual Machine Control Structure）结构实现中断注入控制。

## 中断注入机制概述
中断注入是虚拟化管理程序控制guest操作系统执行流的关键机制。当需要向guest注入中断时，hypervisor通过设置VMCS中的特定字段，在下一次VM entry时触发相应的中断处理。

**Section sources**
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)
- [vcpu.rs](file://src/vmx/vcpu.rs#L942-L960)

## VMCS字段配置
通过`VmcsControl32::VMENTRY_INTERRUPTION_INFO_FIELD`字段配置中断注入信息。该字段包含中断向量号、中断类型和有效性标志等信息。

```mermaid
flowchart TD
Start["开始中断注入"] --> SetVector["设置中断向量"]
SetVector --> SetType["设置中断类型"]
SetType --> SetErrorCode["设置错误码存在标志"]
SetErrorCode --> SetValid["设置有效标志"]
SetValid --> WriteField["写入VM_ENTRY_INTR_INFO_FIELD"]
WriteField --> End["完成注入准备"]
```

**Diagram sources**
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

**Section sources**
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

## 中断类型编码规则
根据`definitions.rs`中的`VmxInterruptionType`枚举定义中断类型：

```mermaid
classDiagram
class VmxInterruptionType {
+External : 0
+Reserved : 1
+NMI : 2
+HardException : 3
+SoftIntr : 4
+PrivSoftException : 5
+SoftException : 6
+Other : 7
}
VmxInterruptionType : vector_has_error_code(vector)
VmxInterruptionType : from_vector(vector)
VmxInterruptionType : is_soft()
```

**Diagram sources**
- [definitions.rs](file://src/vmx/definitions.rs#L150-L180)

**Section sources**
- [definitions.rs](file://src/vmx/definitions.rs#L150-L180)

## 错误码处理
对于需要错误码的异常，系统会自动从`VMEXIT_INTERRUPTION_ERR_CODE`字段获取或使用提供的错误码：

```mermaid
flowchart TD
CheckErrorCode["检查是否需要错误码"] --> HasErrorCode{"需要错误码?"}
HasErrorCode --> |是| UseProvided["使用提供的错误码"]
HasErrorCode --> |否| NoErrorCode["不设置错误码"]
UseProvided --> CheckExist["检查错误码是否存在"]
CheckExist --> |存在| UseExisting["使用现有错误码"]
CheckExist --> |不存在| SetErrorCode["设置新错误码"]
UseExisting --> WriteErrorField["写入VMENTRY_EXCEPTION_ERR_CODE"]
SetErrorCode --> WriteErrorField
WriteErrorField --> Continue["继续注入流程"]
```

**Diagram sources**
- [vmcs.rs](file://src/vmx/vmcs.rs#L720-L725)

**Section sources**
- [vmcs.rs](file://src/vmx/vmcs.rs#L720-L725)

## 注入方法调用流程
`inject_irq`和`inject_exception`方法通过以下流程完成中断注入：

```mermaid
sequenceDiagram
participant Hypervisor as "Hypervisor"
participant VCPU as "VCPU"
participant VMCS as "VMCS"
Hypervisor->>VCPU : 调用inject_irq/inject_exception
VCPU->>VCPU : 验证参数并创建事件
VCPU->>VCPU : 添加到pending_events队列
loop 每次VM entry前
VCPU->>VCPU : 调用inject_pending_events
VCPU->>VCPU : 检查中断是否允许
alt 中断允许
VCPU->>VMCS : 调用inject_event
VMCS->>VMCS : 设置VMENTRY字段
VMCS-->>VCPU : 成功
else 中断被阻塞
VCPU->>VMCS : 启用中断窗口退出
VMCS-->>VCPU : 等待下次机会
end
end
```

**Diagram sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L942-L960)
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

**Section sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L942-L960)
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

## 前置条件检查
在注入中断前需要检查以下条件：

```mermaid
flowchart TD
CheckIF["检查RFLAGS.IF标志"] --> IFSet{"IF=1?"}
IFSet --> |否| BlockInterrupt["阻塞中断"]
IFSet --> |是| CheckBlockState["检查阻塞状态"]
CheckBlockState --> StateZero{"INTERRUPTIBILITY_STATE=0?"}
StateZero --> |否| BlockInterrupt
StateZero --> |是| AllowInject["允许注入"]
AllowInject --> InjectNow["立即注入"]
BlockInterrupt --> EnableWindow["启用中断窗口退出"]
```

**Diagram sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L955-L960)

**Section sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L955-L960)

## PIC/IOAPIC中断模拟示例
模拟传统PIC或IOAPIC中断注入的代码路径：

```mermaid
flowchart LR
ExternalDevice["外部设备产生中断"] --> InterruptController["中断控制器(PIC/IOAPIC)"]
InterruptController --> Hypervisor["Hypervisor捕获中断"]
Hypervisor --> CheckGuestState["检查guest状态"]
CheckGuestState --> CanInject{"可以注入?"}
CanInject --> |是| QueueEvent["添加到pending_events"]
CanInject --> |否| Postpone["推迟注入"]
QueueEvent --> NextEntry["下次VM entry时注入"]
Postpone --> WaitState["等待合适状态"]
WaitState --> TryAgain["尝试重新注入"]
```

**Diagram sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L466)
- [vcpu.rs](file://src/vmx/vcpu.rs#L1443)

**Section sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L466)
- [vcpu.rs](file://src/vmx/vcpu.rs#L1443)

## 注入失败原因分析
中断注入可能失败的原因及应对策略：

```mermaid
erDiagram
FAILURE_REASONS {
string reason PK
string description
string solution
}
GUEST_STATE ||--o{ FAILURE_REASONS : causes
GUEST_STATE {
string state PK
boolean interruptible
boolean in_system_call
}
FAILURE_REASONS }|--|| ERROR_HANDLING : has
ERROR_HANDLING {
string strategy PK
string implementation
}
GUEST_STATE {
"不可中断状态"
"系统调用中"
"NMI窗口"
"MOV SS阻塞"
}
FAILURE_REASONS {
"guest处于不可中断状态" "RFLAGS.IF=0或阻塞状态非零" "启用中断窗口退出"
"guest正在执行敏感指令" "如MOV SS后" "等待指令完成"
"优先级不足" "当前中断优先级过高" "调整注入时机"
}
ERROR_HANDLING {
"延迟注入" "将事件加入队列"
"修改guest状态" "临时启用中断"
"忽略" "某些非关键中断"
}
```

**Diagram sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L942-L960)
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

**Section sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L942-L960)
- [vmcs.rs](file://src/vmx/vmcs.rs#L707-L743)

## 多核环境同步注意事项
在多核环境下进行中断注入时需要注意的同步问题：

```mermaid
graph TB
subgraph "CPU 0"
A[Hypervisor线程]
B[VCPU 0]
end
subgraph "CPU 1"
C[Hypervisor线程]
D[VCPU 1]
end
A --> |锁保护| Shared["共享数据结构"]
C --> |锁保护| Shared
B --> |VMCS绑定| CPU0["物理CPU 0"]
D --> |VMCS绑定| CPU1["物理CPU 1"]
style A fill:#f9f,stroke:#333
style C fill:#f9f,stroke:#333
style Shared fill:#bbf,stroke:#333,color:#fff
style B fill:#9f9,stroke:#333
style D fill:#9f9,stroke:#333
```

**Diagram sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L254-L284)

**Section sources**
- [vcpu.rs](file://src/vmx/vcpu.rs#L254-L284)