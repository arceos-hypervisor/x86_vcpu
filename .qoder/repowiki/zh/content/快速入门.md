# 快速入门

<cite>
**本文档中引用的文件**
- [README.md](file://README.md)
- [rust-toolchain.toml](file://rust-toolchain.toml)
- [src/lib.rs](file://src/lib.rs)
- [src/vmx/mod.rs](file://src/vmx/mod.rs)
- [src/vmx/percpu.rs](file://src/vmx/percpu.rs)
- [src/vmx/vcpu.rs](file://src/vmx/vcpu.rs)
- [src/test_utils.rs](file://src/test_utils.rs)
</cite>

## 目录
1. [简介](#简介)
2. [前置条件](#前置条件)
3. [项目设置与构建](#项目设置与构建)
4. [最小可运行示例](#最小可运行示例)
5. [常见问题与解决方案](#常见问题与解决方案)

## 简介

`x86_vcpu` 是一个为 x86_64 架构提供虚拟 CPU（vCPU）结构定义和虚拟化接口支持的 Rust 库。它主要面向希望在底层实现虚拟化功能的开发者，提供了对 Intel VT-x（VMX）技术的完整支持。本指南旨在帮助新手快速上手，通过本地环境搭建、代码构建和一个简单的运行示例，理解如何使用该库来创建和管理一个基本的 vCPU。

本指南将引导您完成从检查硬件支持到运行一个能处理 VM-exit 事件的 vCPU 的全过程。我们将基于 `test_utils.rs` 中的测试逻辑，为您呈现一个清晰、简洁的工作流。

## 前置条件

在开始之前，请确保您的开发环境满足以下所有要求：

### 硬件要求
- **支持 Intel VT-x 的 CPU**：这是运行此库的绝对前提。大多数现代 Intel 处理器都支持 VT-x，但某些低功耗或旧型号可能不支持。
- **BIOS/UEFI 中启用虚拟化**：即使 CPU 支持 VT-x，也需要在计算机的 BIOS 或 UEFI 设置中手动开启虚拟化技术（通常称为 "Intel Virtualization Technology"、"VT-x" 或 "Vanderpool"）。请重启电脑进入 BIOS 设置界面并查找相关选项进行启用。

### 软件要求
- **特定版本的 Rust 工具链**：该项目依赖于一个特定的 nightly 版本的 Rust 编译器。这个信息被精确地记录在 `rust-toolchain.toml` 文件中。
    - **通道 (channel)**: `nightly-2025-05-20`
    - **组件 (components)**: `rust-src`, `llvm-tools`, `rustfmt`, `clippy`
    - **目标 (targets)**: `x86_64-unknown-none`

Rust 的 `rustup` 工具会自动读取 `rust-toolchain.toml` 文件，并为您安装和切换到正确的工具链版本。只要您在项目根目录下操作，就不需要手动指定编译器版本。

**Section sources**
- [rust-toolchain.toml](file://rust-toolchain.toml)
- [README.md](file://README.md#L1-L101)

## 项目设置与构建

完成前置条件后，您可以按照以下步骤克隆、构建并测试项目。

### 1. 克隆仓库
打开您的终端，执行以下命令来克隆 `x86_vcpu` 仓库：
```bash
git clone https://github.com/arceos-hypervisor/x86_vcpu.git
cd x86_vcpu
```

### 2. 构建项目
使用 Cargo 构建项目。由于项目指定了 `rust-toolchain.toml`，`rustup` 会自动使用正确的 nightly 版本。
```bash
cargo build
```
如果一切顺利，您将看到类似 `Compiling x86_vcpu v0.1.0` 的输出，最终以 `Finished dev [unoptimized + debuginfo] target(s) in X.XXs` 结束。

### 3. 运行测试
运行单元测试以验证代码的基本功能。
```bash
cargo test
```
请注意，许多涉及真实硬件指令（如 `vmxon`）的测试是被跳过的，因为它们只能在具有 VMX 支持且拥有足够权限的环境中运行。您会看到一些测试通过，而另一些则被忽略。

**Section sources**
- [README.md](file://README.md#L1-L101)

## 最小可运行示例

下面是一个简化的、完整的代码示例，展示了如何使用 `x86_vcpu` 库的核心功能。此示例的逻辑直接来源于 `test_utils.rs` 和 `vmx/vcpu.rs` 中的测试代码。

```rust
use x86_vcpu::{has_hardware_support, VmxArchPerCpuState, VmxArchVCpu};
use axvcpu::AxVCpuHal;
use memory_addr::PhysAddr;

// 您必须为 AxVCpuHal trait 提供一个实现。
// 在实际应用中，这将包含内存管理等底层操作。
struct MyHal;

impl AxVCpuHal for MyHal {
    type MmHal = (); // 此处仅为简化，实际实现需具体化
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. 检查硬件支持
    if !has_hardware_support() {
        eprintln!("错误：CPU 不支持 VMX 硬件虚拟化！");
        return Err("缺少 VMX 支持".into());
    }
    println!("检测到 VMX 硬件支持");

    // 2. 初始化每 CPU 状态
    let mut per_cpu_state = VmxArchPerCpuState::<MyHal>::new(0)?;
    per_cpu_state.hardware_enable()?; // 启用 VMX 模式
    println!("成功启用 VMX 模式");

    // 3. 创建 vCPU 实例
    let vm_id = 0.into(); // 虚拟机 ID
    let vcpu_id = 0.into(); // vCPU ID
    let mut vcpu = VmxArchVCpu::<MyHal>::new(vm_id, vcpu_id)?;

    // 4. 设置 EPT 根地址和入口点
    // （此处仅为示意，实际值需根据您的虚拟机配置）
    let ept_root_paddr = PhysAddr::from(0x1000_0000); // 示例物理地址
    let guest_entry_point = PhysAddr::from(0x1000); // 客户机入口点
    vcpu.set_ept_root(ept_root_paddr)?;
    vcpu.set_entry(guest_entry_point)?;

    // 5. 绑定 vCPU 并启动
    vcpu.bind()?;
    match vcpu.run() {
        Ok(exit_reason) => {
            println!("vCPU 退出，原因: {:?}", exit_reason);
            // 在这里处理不同的退出原因，例如 I/O 请求、超调用等
        }
        Err(e) => {
            eprintln!("vCPU 运行出错: {}", e);
        }
    }

    // 清理
    vcpu.unbind()?;
    per_cpu_state.hardware_disable()?;
    Ok(())
}
```

### 代码解释

1.  **检查硬件支持 (`has_hardware_support`)**:
    - **作用**: 调用 `raw_cpuid` 库查询 CPU 功能位，确认是否支持 VMX 指令集。
    - **预期输出**: 如果支持，打印“检测到 VMX 硬件支持”；否则程序报错退出。

2.  **初始化 `VmxPerCpuState`**:
    - **作用**: 为当前 CPU 核心创建一个状态对象，用于管理 VMCS（虚拟机控制结构）区域。
    - **`hardware_enable()`**: 执行关键的 `VMXON` 指令，将 CPU 切换到 VMX 操作模式。这需要 root 权限（Linux 下的 `CAP_SYS_ADMIN`）。
    - **预期输出**: 成功时打印“成功启用 VMX 模式”。

3.  **创建 `VmxVcpu` 实例**:
    - **作用**: 创建一个代表客户机虚拟 CPU 的实例。它包含了寄存器状态、VMCS 配置等。
    - **`set_ept_root()`**: 设置扩展页表（EPT）的根物理地址，用于内存虚拟化。
    - **`set_entry()`**: 设置客户机操作系统启动时的第一条指令地址（RIP）。

4.  **启动 vCPU (`run`)**:
    - **作用**: 调用 `bind()` 将 vCPU 的 VMCS 加载到当前 CPU，然后调用 `inner_run()` 执行 `VMLAUNCH` 指令，正式将控制权交给客户机。
    - **处理 VM-exit**: 当客户机触发中断、执行 I/O 指令或发生其他事件时，CPU 会退出到宿主机（即我们的代码），`run()` 函数返回一个 `AxVCpuExitReason`。开发者需要根据这个原因进行相应的处理（如模拟 I/O 设备）。

**Section sources**
- [src/lib.rs](file://src/lib.rs#L30)
- [src/vmx/mod.rs](file://src/vmx/mod.rs#L16-L35)
- [src/vmx/percpu.rs](file://src/vmx/percpu.rs#L44)
- [src/vmx/vcpu.rs](file://src/vmx/vcpu.rs#L1318-L1399)

## 常见问题与解决方案

在尝试运行此代码时，您可能会遇到以下常见问题：

### 1. 缺少硬件支持
- **错误信息**: `错误：CPU 不支持 VMX 硬件虚拟化！`
- **原因**: 您的 CPU 不支持 Intel VT-x，或者该功能在 BIOS/UEFI 中被禁用。
- **解决方案**:
    1.  确认您的 CPU 型号是否支持 VT-x（可通过查阅 Intel ARK 数据库）。
    2.  重启电脑，进入 BIOS/UEFI 设置，找到 "Advanced" -> "CPU Configuration" 或类似菜单，将 "Intel Virtualization Technology" 设置为 "Enabled"。

### 2. 权限不足
- **错误信息**: `VMX instruction vmxon failed: ...` 或 `Operation not permitted`
- **原因**: `VMXON` 指令是特权指令，普通用户进程无权执行。
- **解决方案**:
    - **Linux**: 使用 `sudo` 运行您的程序，或者将您的用户添加到 `kvm` 组（如果系统有 KVM 模块）。
    - **注意**: 在生产级虚拟化软件中，通常会以内核模块或具有特殊能力的守护进程形式运行。

### 3. 工具链版本不匹配
- **错误信息**: 编译错误，提示找不到某些 nightly 特性或语法。
- **原因**: 您没有使用 `rust-toolchain.toml` 中指定的 `nightly-2025-05-20` 版本。
- **解决方案**: 确保您已安装 `rustup`，并且在 `x86_vcpu` 项目的根目录下执行 `cargo` 命令。`rustup` 会自动为您切换工具链。

**Section sources**
- [README.md](file://README.md#L1-L101)
- [rust-toolchain.toml](file://rust-toolchain.toml)
- [src/vmx/percpu.rs](file://src/vmx/percpu.rs#L44-L47)